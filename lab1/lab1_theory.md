# Теория по лабораторной работе с Docker, Nginx и HTTPS

## Docker
Docker - программа, позволяющая создавать нам контейнеры (мини-системы, которые используют ядро локального устройства и не имеют в себе никакой ос, сторонних процессов или драйверов. Внутри мы просто запускаем наши файлы/приложения/проекты). В работе нужен чтобы изолировать основную систему от выполняемых процессов, чтобы избежать конфликтов при запуске кода на разных системах

## Docker compose
Docker compose - подпрограмма Docker, позволяющая запускать сразу несколько контейнеров (?)

---

## Протоколы HTTP, HTTPS
HyperText Transfer Protocol - протоколы передачи данных в интернете.  
Как работает HTTPS?  
Клиент образается к серверу, сервер отдает сертификат (внутри открытый ключ) клиент проверяет сертификат(домен, срок действия, владельца, подпись), если проверка успешка - устанавливается TLS сессия и данные передаются уже шифрованными

---

## SSL и TLS
- SSL (Secure Sockets Layer) устаревшее название  
- TSL (Transport Layer Security) синоним  
- Это та самая буква S в конце протокола HTTPS

### обычный HTTP:
передает данные открыто, не проходит проверку браузуеров и так далее

### HTTPS:
Шифрует данные при передаче, атуетификация через сертификат (?)  

Сертификаты - это электронные документы, которые подтверждают домен, владельца, срок действия и имеют подпись. Сертификат содержит открытый ключ, закрытый ключ хранится у сервера.

### Сертификаты есть разных видов:
1. Самоподписанные (браузеры ругаются, для учебы норм)
2. Let's Encrypt - бесплатный, используется в продакшене
3. Платные (напр Wildcard) - используются большими компаниями

---

## Структура проекта

```
.
├── docker-compose.yml
├── nginx
│   └── nginx.conf
├── site1
│   └── index.html
├── site2
│   └── index.html
└── ssl
    ├── cert.pem
    └── key.pem
```

---

## docker-compose
docker-compose - файл, координирующий работу

## nginx
nginx - веб сервер и обратный прокси-сервер. Используется для статических файлов (веб страницы например), приема http(s) запросов. Например клиент пишет в бразуере домен страницы, запрос приходит в nginx и он исходя из своего конфига решает, что делать с запросом.

## nginx.conf
nginx.conf - файл-настройка nginx, в нем мы указываем всю информацию: какие домены он обслуживает, какие порты слушает (80/443), где лежат сертификаты и так далее.  

Правильная структура:

```nginx
events {}

http {
    # site1 redirect
    server {
        listen 80;
        server_name site1.local;
        return 301 https://$host$request_uri; # 301 - moved permanently
    }

    # site1: HTTPS
    server {
        listen 443 ssl;
        server_name site1.local;

        ssl_certificate     /etc/nginx/ssl/cert.pem;
        ssl_certificate_key /etc/nginx/ssl/key.pem;

        location / { # / указывает какие запросы будут обработаны (все), могла быть конекретика, например /name/
            root /usr/share/nginx/html/site1;
            index index.html;
        }

        location /images/ { # пример запроса и alias то есть пользователь обращается через .../images/..., но на сервере контент ищется в .../folder_images/...
            alias /usr/share/nginx/html/site1/folder_images/;
        } # Это нужно чтобы дать пользователю красивый путь, а не как правильно на севере
    }

    # site2 redirect
    server {
        listen 80;
        server_name site2.local;
        return 301 https://$host$request_uri; # 301 - moved permanently
    }

    # site2: HTTPS
    server {
        listen 443 ssl;
        server_name site2.local;

        ssl_certificate     /etc/nginx/ssl/cert.pem;
        ssl_certificate_key /etc/nginx/ssl/key.pem;

        location / {
            root /usr/share/nginx/html/site2;
            index index.html;
        }
    }
}
```

---

## ssl
ssl - папка с сертификатом (cert) и приватным ключом (key). В идеале, у каждого домена свой cert & key, но в улсовиях лабы, мы это опустим  

### Генерация cert & key
```bash
openssl req -x509 -nodes -days 365   -newkey rsa:2048   -keyout ssl/key.pem   -out ssl/cert.pem   -subj "/CN=site1.local"
```

Разбор по частям:  
- openssl - утилита для работы с сертификатами  
- req - реквест на сертификат  
- -x509 флаг, утверждающий, что запрос к самоподписанному сертификату (для остальных, видимо, другие флаги)  
- -nodes (no DES) не шифровать приватный ключ паролем, то есть nginx будет иметь к нему доступ без пароля  
- -days 365 срок действия сертификата в днях (365)  
- -newkey rsa:2048 - генерируется новая пара ключей через алгоритм шифрования rsa, длина ключа 2048 бит  
- -keyout ssl/key.pem - путь записи приватного ключа  
- -out ssl/cert.pem - путь записи самоподписанного сертификата  
- -subj "/CN=site1.local" Subject - данные владельца сертификата, CN - common name - типа домен.  

Эту команду, само собой, нужно выполнять в терминале в подходящей директории.

```bash
openssl x509 -in ssl/cert.pem -text -noout # Вывод данных о сертификате
```

---

## Docker-compose
Этот файл содержит сценарии, где описано, какие сервисы запускать, какие папки подключать, какие порты пробрасывать. Один раз прописываем окружение, а потом запускаем всё командой.  

docker-compose.yml = инструкция:
- какой контейнер запустить (nginx),
- какие порты открыть (80/443),
- какие папки примонтировать (сайты, ssl, конфиг).

```bash
docker compose up -d # включение, благодаря -d логи nginx не выводятся в терминал
docker compose down # выключение
docker compose ps # информация о состоянии контейнера
```

---

## docker-compose.yml
```yaml
services: # Указывает список сервисов, которыми мы будем оперировать при помощи этого докер компоуз
  nginx:
    image: nginx:alpine
    ports:
      - "80:80" # HOST_PORT:CONTAINER_PORT
      - "443:443" 
    volumes: # Тома. С помощью volumes мы подключаем сторонние файлы, которые и хотим использовать к nginx(серверу)
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf # использует наш кфг
      - ./site1:/usr/share/nginx/html/site1 # файлы сайтов
      - ./site2:/usr/share/nginx/html/site2
      - ./ssl:/etc/nginx/ssl # файлы cet & key
```

---

## /etc/hosts
```bash
% sudo nano /etc/hosts
```
Добавили сюда наши:
```
127.0.0.1 site1.local site2.local
```
чтобы система знала об этих фейк доменах.
